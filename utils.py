import torch


def transpose_qkv(X, num_heads):
    X = X.reshape(X.shape[0], X.shape[1], num_heads, -1)

    X = X.permute(0, 2, 1, 3)

    return X.reshape(-1, X.shape[2], X.shape[3])


def transpose_output(X, num_heads):
    X = X.reshape(-1, num_heads, X.shape[1], X.shape[2])
    X = X.permute(0, 2, 1, 3)
    return X.reshape(X.shape[0], X.shape[1], -1)


def compute_advantage(gamma, lmbda, td_delta):
    td_delta = td_delta.detach().numpy()
    advantage_list = []
    advantage = 0.0
    for delta in td_delta[::-1]:
        advantage = gamma * lmbda * advantage + delta
        advantage_list.append(advantage)
    advantage_list.reverse()
    return torch.tensor(advantage_list, dtype=torch.float)


class EpsilonOptimizer:
    def __init__(self, start_epsilon=0.9, min_epsilon=0.4, decay=0.995):
        self.epsilon = start_epsilon
        self.min_epsilon = min_epsilon
        self.decay = decay

    def step(self):

        self.epsilon = max(self.min_epsilon, self.epsilon * self.decay)

    def get_epsilon(self):

        return self.epsilon
